# OfferOriented-DS_AL

## 第一章 整数

### 1.1 整数基础

#### 问题01:整数除法

- **输入**2个**int**型整数，进行除法运算后返回商。
不得使用乘号(‘*‘)，除号(‘/’)和求余符号(‘%’)。
溢出时返回整数最大值。假设除数不为0。
    - O(n)
        1. 被除数(a)是否小于除数(b); 是, 结果为做减法的次数q; 否,继续步骤 2)
        2. 被除数减去除数(a-b,q++), 结果作为新的被除数, 继续步骤 1)
        
    - O(logn)
        1. 被除数(a)是否小于除数(b); 是,结果为做减法的次数q; 否,继续步骤 2)
        2. 寻找满足 $b\times 2^k \leq a < b \times 2^{k+1}$的 k 的值 (注意: b不能大于$2^{30}$, 否则计算$2\times b$就会溢出)
        3. $a-b\times 2^k$ 作为新的被除数, 此时减法次数为 $q=2^k$, 继续步骤 1) 
    - 临界值
        - 32为有符号整数范围为: $[-2^{31}, 2^{31}-1]$; 仅有计算$-2^{31}\div -1$ 时会溢出
    - 符号
        - 结果符号取在计算前即可得出
        - 由于正数的范围小于负数, 故需要将数字全部转换为负数进行计算(注意比较时大于小于会颠倒) 
### 1.2 二进制
#### 问题02: 二进制加法
- 输入两个表示二进制的字符串，
  计算其和并以二进制字符串形式输出。
    1. 将字符按位对齐, 字符可以通过减去字符'0'来转换成数字
    2. 按照逢二进一的规则计算
    3. 计算完毕后,判断进位(carry)是否为1,决定是否需要增加最高位1
#### 问题03: 前n个数字的二进制形式1的个数
- 输入**非负数**n，计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。
    - 问题可以转化位求一个数字的二进制形式的1的个数
    - O(nk)
      1. 核心: i&(i-1) 会将i的最右边的1置0
      2. 执行k次之后,i所有位置都是0, 那么1的个数就为k
    - O(n)
        1. i 比 i&(i-1) 多一个1
        2. 利用之前已经得到结果计算后续的值
    - O(n)
        1. 奇数最后一位必为1
        2. 偶数i和i>>1, 1的个数相同 (i&1=0)
           奇数i比i>>1, 多一个1 (i&1=1)
        3. 使用位运算代替四则运算
            i>>1 <--> i/2
            i&1  <--> i%2
#### 问题04: 只出现M次的数字
- 输入整数数组,只有一个数字出现m次, 其余都是n次,且m不能被n整除,找出现m次的数字
    1. 将所有数字的二进制按位累加起来
    2. 每个位置的和去除n, 
    若能整除则说明目标数字的此位置一定为0;
    不能,则此位置一定为1(计算过程中与m无关)
#### 问题05: 单词长度的最大乘积
- 输入字符串数组 words, 计算不包含相同字符的字符串word[i]和word[j]的长度乘积的最大值. 若每个都至少包含一个相同字符则输出0.假设仅包含小写字母
  - $O(n^4)$
    1. 每个字符串两两匹配
    2. 每个字符串的字符相互匹配
  - TC:$O(nk+n^2)$
    SC:O(n)
    1. 构建哈希表([n][26]bool), 将每个字符串的字母出现情况录入到表中 TC: O(nk), k为字符串长度
    2. 字符串两两匹配, 匹配字符时直接查询哈希表 $O(n^2)$
  - TC:$O(nk+n^2)$
    SC:O(n)
    **使用位运算效率更高**
    1. 构建整数数组,将每个字符出现情况用二进制0和1来记录
    2. 字符串匹配时,将数字进行与运算,若为0则不含相同字母.